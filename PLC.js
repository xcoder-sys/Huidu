/**
 * 8路开关控制器模块 (ES5 兼容版本)
 * * 输入:
 * - Pos1..8 (digital): 对应 1-8 路的启动信号 (上升沿有效)
 * - Pos9..16 (digital): 对应 1-8 路的关闭信号 (上升沿有效)
 * * 输出:
 * - Pos1 (serial): 发送的控制指令字节数组。
 */
function call(MPV) {
	// 1. 定义16条指令，与输入Pos1到Pos16一一对应
	var commands = [
		// 启动指令 (Pos1 -> Pos8)
		new Uint8Array([
			0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x32, 0x05, 0x03, 0xeb, 0xff, 0x00,
		]), // Pos1: 第1路启动
		new Uint8Array([
			0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x32, 0x05, 0x03, 0xed, 0xff, 0x00,
		]), // Pos2: 第2路启动
		new Uint8Array([
			0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x32, 0x05, 0x03, 0xef, 0xff, 0x00,
		]), // Pos3: 第3路启动
		new Uint8Array([
			0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x32, 0x05, 0x03, 0xf1, 0xff, 0x00,
		]), // Pos4: 第4路启动
		new Uint8Array([
			0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x32, 0x05, 0x03, 0xf3, 0xff, 0x00,
		]), // Pos5: 第5路启动
		new Uint8Array([
			0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x32, 0x05, 0x03, 0xf5, 0xff, 0x00,
		]), // Pos6: 第6路启动
		new Uint8Array([
			0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x32, 0x05, 0x03, 0xf7, 0xff, 0x00,
		]), // Pos7: 第7路启动
		new Uint8Array([
			0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x32, 0x05, 0x03, 0xf9, 0xff, 0x00,
		]), // Pos8: 第8路启动
		// 关闭指令 (Pos9 -> Pos16)
		new Uint8Array([
			0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x32, 0x05, 0x03, 0xec, 0xff, 0x00,
		]), // Pos9: 第1路关闭
		new Uint8Array([
			0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x32, 0x05, 0x03, 0xee, 0xff, 0x00,
		]), // Pos10: 第2路关闭
		new Uint8Array([
			0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x32, 0x05, 0x03, 0xf0, 0xff, 0x00,
		]), // Pos11: 第3路关闭
		new Uint8Array([
			0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x32, 0x05, 0x03, 0xf2, 0xff, 0x00,
		]), // Pos12: 第4路关闭
		new Uint8Array([
			0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x32, 0x05, 0x03, 0xf4, 0xff, 0x00,
		]), // Pos13: 第5路关闭
		new Uint8Array([
			0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x32, 0x05, 0x03, 0xf6, 0xff, 0x00,
		]), // Pos14: 第6路关闭
		new Uint8Array([
			0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x32, 0x05, 0x03, 0xf8, 0xff, 0x00,
		]), // Pos15: 第7路关闭
		new Uint8Array([
			0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x32, 0x05, 0x03, 0xfa, 0xff, 0x00,
		]), // Pos16: 第8路关闭
	];

	// 2. 初始化MRV对象
	var mrv = {
		Output: {
			Pos1: null,
		},
		PrivateInfo: {
			InputPreviousValue:
				(MPV.PrivateInfo && MPV.PrivateInfo.InputPreviousValue) || {},
		},
		Refresh: [],
		Token: MPV.Token,
	};

	// 3. 核心逻辑：从高到低遍历输入，实现高位优先
	// i 从 15 (Pos16) 循环到 0 (Pos1)
	for (var i = 15; i >= 0; i--) {
		var inputName = "Pos" + (i + 1);
		var currentInput = MPV.Input[inputName];

		if (currentInput) {
			var currentValue = currentInput.SignalValue;
			var previousValue = !!mrv.PrivateInfo.InputPreviousValue[inputName];

			// 上升沿检测
			if (currentValue === true && previousValue === false) {
				// 触发成功，设置输出指令
				mrv.Output.Pos1 = commands[i];
				mrv.Refresh.push("Pos1");
				// 找到第一个触发的信号后，立即跳出循环，不再检查其他低优先级的信号
				break;
			}
		}
	}

	// 4. 状态保存：无论是否触发，都需要保存本次所有输入的状态，供下次比较
	for (var j = 0; j < 16; j++) {
		var name = "Pos" + (j + 1);
		var input = MPV.Input[name];
		// 如果输入存在，则记录其值；否则记录为false
		mrv.PrivateInfo.InputPreviousValue[name] = input
			? input.SignalValue
			: false;
	}

	// 5. 返回结果
	return mrv;
}
